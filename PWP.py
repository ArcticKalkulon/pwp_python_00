"""
This is a Python implementation of the Price Weller Pinkel (PWP) ocean mixed layer model.
This code is based on the MATLAB implementation of the PWP model originally
written by Peter Lazarevich and Scott Stoermer (http://www.po.gso.uri.edu/rafos/research/pwp/)
(U. Rhode Island) and later modified by Byron Kilbourne (University of Washington)
and Sarah Dewey (University of Washington).

The run() function provides an outline of how the code works.

Earle Wilson
School of Oceanography
University of Washington
April 18, 2016
"""

import numpy as np
import seawater as sw
import matplotlib.pyplot as plt
from IPython.core.debugger import Tracer
import xray
import pickle
import timeit
import os
from datetime import datetime
import PWP_helper as phf
import PWP_ice
import imp

imp.reload(phf)
imp.reload(PWP_ice)

debug_here = Tracer()

def run(met_data, prof_data, param_kwds=None, overwrite=True, diagnostics=False, suffix='', save_plots=False):
    
    """
    This is the main controller function for the model. The flow of the algorithm
    is as follows:
        
        1) Set model parameters (see set_params function in PWP_helper.py).
        2) Read in forcing and initial profile data.
        3) Prepare forcing and profile data for model run (see prep_data in PWP_helper.py).
            3.1) Interpolate forcing data to prescribed time increments.
            3.2) Interpolate profile data to prescribed depth increments.
            3.3) Initialize model output variables.
        4) Iterate the PWP model specified time interval:
            4.1) apply heat and salt fluxes
            4.2) rotate, adjust to wind, rotate
            4.3) apply bulk Richardson number mixing
            4.4) apply gradient Richardson number mixing
            4.5) apply drag associated with internal wave dissipation
            4.5) apply diapycnal diffusion
        5) Save results to output file
    
    Input:
    met_data -  path to netCDF file containing forcing/meterological data. This file must be in the
                input_data/ directory.
                
                The data fields should include 'time', 'sw', 'lw', 'qlat', 'qsens', 'tx',
                'ty', and 'precip'. These fields should store 1-D time series of the same
                length.
                
                The model expects positive heat flux values to represent ocean warming. The time
                data field should contain a 1-D array representing fraction of day. For example,
                for 6 hourly data, met_data['time'] should contain a number series that increases
                in steps of 0.25, such as np.array([1.0, 1.25, 1.75, 2.0, 2.25...]).
                
                See https://github.com/earlew/pwp_python#input-data for more info about the
                expected intput data.
    
    prof_data - path to netCDF file containing initial profile data. This must be in input_data/ directory.
                Fields should include: ['z', 't', 's', 'lat']. These represent 1-D vertical profiles of temperature,
                salinity and density. lat can (should?) be a float.
                
                See https://github.com/earlew/pwp_python#input-data for more info about the
                expected intput data
    
    overwrite - controls the naming of output file. If True, the same filename is used for
                every model run. If False, a unique time_stamp is generated and appended
                to the file name. Default is True.
    
    diagnostics - if True, the code will generate live plots of mixed layer properties at
                each time step (makes the code run a lot SLOWER). Default is False
    
    suffix - string to add to the end of filenames. e.g. suffix = 'nodiff' leads to 'pwp_out_nodiff.nc.
            default is an empty string ''.
    
    save_plots -this gets passed on to the makeSomePlots() function in the PWP_helper. If True, the code
                saves the generated plots. Default is False.
    
    param_kwds -dict containing keyword arguments for set_params function. See PWP_helper.set_params()
                for more details. If None, default parameters are used. Default is None.
    
    Output:
    
    forcing, pwp_out = PWP.run()
    
    forcing: a dictionary containing the interpolated surface forcing.
    pwp_out: a dictionary containing the solutions generated by the model.
    
    This script also saves the following to file:
    
    'pwp_output.nc'- a netCDF containing the output generated by the model.
    'pwp_output.p' - a pickle file containing the output generated by the model.
    'forcing.p' - a pickle file containing the (interpolated) forcing used for the model run.
    If overwrite is set to False, a timestamp will be added to these file names.
    
    ------------------------------------------------------------------------------
    There are two ways to run the model:
    1.  You can run the model by typing "python PWP.py" from the bash command line. This
        will initiate this function with the set defaults. Typing "%run PWP" from the ipython
        command line will do the same thing.
    
    2.  You can also import the module then call the run() function specifically. For example,
        >> import PWP
        >> forcing, pwp_out = PWP.run()
        Alternatively, if you want to change the defaults...
        >> forcing, pwp_out = PWP.run(met_data='new_forcing.nc', overwrite=False, diagnostics=False)
    
    This is a more interactive approach as it provides direct access to all of the model's
    subfunctions.
    
    """
    
    #close all figures
    plt.close('all')
    
    #start timer
    t0 = timeit.default_timer()
    
    ## Get surface forcing and profile data
    # These are x-ray datasets, but you can treat them as dicts.
    # Do met_dset.keys() to explore the data fields
    met_dset = xray.open_dataset('input_data/%s' %met_data)
    prof_dset = xray.open_dataset('input_data/%s' %prof_data)
    
    ## get model parameters and constants (read docs for set_params function)
    try:
        lat = prof_dset['lat'].values[0] #needed to compute internal wave dissipation
    except IndexError:
        lat = prof_dset['lat'].values
    
    if param_kwds is None:
        params = phf.set_params(lat=lat)
    else:
        param_kwds['lat'] = lat
        params = phf.set_params(**param_kwds)
    
    #debug_here()
    ## prep forcing and initial profile data for model run (see prep_data function for more details)
    forcing, pwp_out, params = phf.prep_data(met_dset, prof_dset, params)
    
    prof_dset.close()
    met_dset.close()
    
    # plot forcing
    phf.makeSomePlots(forcing, pwp_out, justForcing=True)
    plt.show()
    
    debug_here()
    ## run the model
    pwp_out = pwpgo(forcing, params, pwp_out, diagnostics)
    
    #check timer
    tnow = timeit.default_timer()
    t_elapsed  = (tnow - t0)
    print("Time elapsed: %i minutes and %i seconds" %(np.floor(t_elapsed/60), t_elapsed%60))
    
    ## write output to disk
    if overwrite:
        time_stamp = ''
    else:
        #use unique time stamp
        time_stamp = datetime.now().strftime("_%Y%m%d_%H%M")
    
    if len(suffix)>0 and suffix[0] != '_':
        suffix = '_%s' %suffix
    
    # save output as netCDF file
    output_fpath = "output/pwp_output%s%s.nc" %(suffix, time_stamp)
    forcing_fpath = "output/forcing%s%s.nc" %(suffix, time_stamp)
    
    pwp_out2 = phf.save2nc(pwp_out, output_fpath, dt_save=params['dt_save'])
    forcing2 = phf.save2nc(forcing, forcing_fpath, dt_save=params['dt_save'], type='forc')
    
    #debug_here()
    ## do analysis of the results
    phf.makeSomePlots(forcing2, pwp_out2, suffix=suffix, save_plots=save_plots)
    
    return forcing2, pwp_out2

def absorb(beta1, beta2, zlen, dz):
    
    # Compute solar radiation absorption profile. This
    # subroutine assumes two wavelengths, and a double
    # exponential depth dependence for absorption.
    #
    # Subscript 1 is for red, non-penetrating light, and
    # 2 is for blue, penetrating light. rs1 is the fraction
    # assumed to be red.
    
    rs1 = 0.6
    rs2 = 1.0-rs1
    z1 = np.arange(0,zlen)*dz
    z2 = z1 + dz
    z1b1 = z1/beta1
    z2b1 = z2/beta1
    z1b2 = z1/beta2
    z2b2 = z2/beta2
    absrb = rs1*(np.exp(-z1b1)-np.exp(-z2b1))+rs2*(np.exp(-z1b2)-np.exp(-z2b2))
    
    return absrb

def pwpgo(forcing, params, pwp_out, diagnostics):
    
    """
    This is the main driver of the PWP module.
    """
    print_ice_warning = True
    print_lead_warning = True
    transition_ice_frac = False
    
    #define reference salinity and density (use these when computing heat fluxes)
    sal_ref = 34.0
    dens_ref = 1026.0
    
    #unpack some of the variables (I could probably do this more elegantly)
    q_in = forcing['q_in']
    q_out = forcing['q_out']
    emp = forcing['emp']
    taux = forcing['tx']
    tauy = forcing['ty']
    absrb = forcing['absrb']
    forcing['icec2'] = forcing['icec'].copy()
    
    
    z = pwp_out['z']
    dz = pwp_out['dz']
    dt = pwp_out['dt']
    zlen = len(z)
    tlen = len(pwp_out['time'])
    
    rb = params['rb']
    rg = params['rg']
    f = params['f']
    cpw = params['cpw']
    g = params['g']
    ucon = params['ucon']
    # alpha = params['alpha']
    
    q_net = q_in-q_out
    q_net = q_net+params['qnet_offset']
    
    #add dz and dt to params
    params['dt'] = dt
    params['dz'] = dz
    
    #create output variable for ocean and atmospheric heat flux (TODO: move to PWP_helper???)
    pwp_out['F_oi'] = np.zeros(len(pwp_out['ice_thickness']))*np.nan #ocean-ice heat flux
    pwp_out['F_ao'] = np.zeros(len(pwp_out['ice_thickness']))*np.nan #atmosphere-ocean heat flux
    pwp_out['F_ai'] = np.zeros(len(pwp_out['ice_thickness']))*np.nan #atmosphere-ice heat flux
    pwp_out['F_i'] = np.zeros(len(pwp_out['ice_thickness']))*np.nan #heat flux through the ice
    pwp_out['F_ent'] = np.zeros(len(pwp_out['ice_thickness']))*np.nan
    
    pwp_out['q_sens_ao'] = np.zeros(len(pwp_out['ice_thickness']))*np.nan
    pwp_out['q_lat_ao'] = np.zeros(len(pwp_out['ice_thickness']))*np.nan
    pwp_out['q_lw_ao'] = np.zeros(len(pwp_out['ice_thickness']))*np.nan
    pwp_out['q_net_ao'] = np.zeros(len(pwp_out['ice_thickness']))*np.nan
    
    pwp_out['q_sens_ai'] = np.zeros(len(pwp_out['ice_thickness']))*np.nan
    pwp_out['q_lat_ai'] = np.zeros(len(pwp_out['ice_thickness']))*np.nan
    pwp_out['q_lw_ai'] = np.zeros(len(pwp_out['ice_thickness']))*np.nan
    pwp_out['q_net_ai'] = np.zeros(len(pwp_out['ice_thickness']))*np.nan
    
    pwp_out['mld_exact'] = np.zeros(len(pwp_out['mld']))*np.nan
    pwp_out['mld_exact2'] = np.zeros(len(pwp_out['mld']))*np.nan
    pwp_out['mlt'] = np.zeros(len(pwp_out['mld']))*np.nan
    pwp_out['mls'] = np.zeros(len(pwp_out['mld']))*np.nan
    pwp_out['mlt_elev'] = np.zeros(len(pwp_out['mld']))*np.nan
    pwp_out['alpha_true'] = np.zeros(len(pwp_out['mld']))
    pwp_out['ice_start'] = []
    
    #initialize ice thickness:
    pwp_out['ice_thickness'][0] = params['h_i0']
    if params['h_i0'] > 0.0:
        print("Initializing ice model with %sm slab of ice." %params['h_i0'])
    #TESTING
    # pwp_out['ice_thickness'][0] = 0.2
    # pwp_out['surf_ice_temp'][0] = -2
    
    
    #debug_here()
    print("Number of time steps: %s" %tlen)
    
    for n in range(1,tlen):
        #print '-------------------------------'
        print('====================================')
        percent_comp = 100*n/float(tlen)
        yr = np.floor(pwp_out['time'][n]/365); day =pwp_out['time'][n]%365
        print('Loop iter. %s (%.1f %%). Year: %i,   Day: %.2f' %(n, percent_comp, yr, day))
        #print '===================================='
        
        #select previous profile data
        temp = pwp_out['temp'][:, n-1].copy()
        sal = pwp_out['sal'][:, n-1].copy()
        dens = pwp_out['dens'][:, n-1].copy()
        uvel = pwp_out['uvel'][:, n-1].copy()
        vvel = pwp_out['vvel'][:, n-1].copy()
        ps = pwp_out['ps'][:, n-1].copy()
        
        h_ice = pwp_out['ice_thickness'][n-1].copy()
        temp_ice_surf = pwp_out['surf_ice_temp'][n-1].copy()
        
        
        #compute mlt and mls before applying surface fluxes
        mld_pre, mld_idx_pre = getMLD(dens, z, params)
        
        #select previous forcing data
        # F_atm = q_net[n-1]
        #alpha_n = params['alpha']
        alpha_n = forcing['icec2'][n-1]
        skt_n = forcing['skt'][n-1]
        
        
        #save initial T,S (may not be necessary)
        # temp_old = pwp_out['temp'][0, n-1]
        sal_old = pwp_out['sal'][0, n-1]
        T_fz = sw.fp(sal_ref, p=1)
        
        
        ### Absorb solar radiation and FWF in surf layer ###
        if h_ice==0:
            
            #set alpha (ice fraction) to 0.0:
            alpha_n = 0.0
            
            if params['csf'] == True:
                #computes atmosphere-ocean fluxes - everything but shortwave
                q_lw_ao, q_sens_ao, q_lat_ao = get_atm_ocean_HF(temp[0], forcing, alpha_n, n)
                q_in_ao = (1-alpha_n)*q_in[n-1]
                q_out_ao = -(q_lw_ao+q_sens_ao+q_lat_ao) #fluxes were defined as positive down. ice fraction already accoutned for
                q_net_ao = q_in_ao-q_out_ao
                
                pwp_out['q_sens_ao'][n-1] = q_sens_ao
                pwp_out['q_lat_ao'][n-1] = q_lat_ao
                pwp_out['q_lw_ao'][n-1] = q_lw_ao
                pwp_out['q_net_ao'][n-1] = q_net_ao
            
            else:
                q_in_ao = q_in[n-1]
                q_out_ao = q_out[n-1]
                q_net_ao = q_net[n-1]
            
            
            #update layer 1 temp and sal
            temp[0] = temp[0] + (q_in_ao*absrb[0]-q_out_ao)*dt/(dz*dens_ref*cpw)
            sal[0] = sal[0] + sal_ref*emp[n-1]*dt/dz
            
            ### Absorb rad. at depth ###
            temp[1:] = temp[1:] + q_in_ao*absrb[1:]*dt/(dz*dens_ref*cpw)
            
            #check if temp is less than freezing point
            #T_fz = sw.fp(sal[0], p=dz) #why use sal_old? Need to recheck
            ice_heating = 0.0
            if temp[0] < T_fz:
                # debug_here()
                ice_heating = (T_fz-temp[0])*dens_ref*cpw*dz/dt #need to add artificial warming flux to compensate for ice growth
                if params['ice_ON']:
                    pwp_out['ice_start'].append(pwp_out['time'][n])
                    #generate sea ice (aka frazil ice)
                    h_ice, temp_ice_surf, temp, sal = PWP_ice.create_initial_ice(h_ice, temp_ice_surf, temp, sal, dens, alpha_n, params)
                    pwp_out['surf_ice_temp'][n] = temp_ice_surf
                    pwp_out['ice_thickness'][n] = h_ice

                    # debug_here()
                else:
                    temp[0] = T_fz
                    if print_ice_warning:
                        print("surface has reached freezing temp. However, ice creation is either turned off or ice_conc is set to zero.")
                        print_ice_warning = False
            
            pwp_out['F_ao'][n-1] = q_net_ao+ice_heating
            
            #TODO: update layer 1 of passive scalar
        
        else:
            
            ## get ice concentration
            
            #need to implement a smooth transition in ice-fraction from open water to non-zero ice percentage
            #without this, ice frac can abruptly transition from open ocean to >50% ice cover
            
            if transition_ice_frac:
                alpha_true = pwp_out['alpha_true'][n-1]
                alpha_forc = alpha_n
                d_alpha = alpha_true-alpha_forc
                if np.abs(d_alpha)>0.05:
                    t_adj = int(10*(1./params['dt_d'])) #give model 10 days to catch up to the ice frac forcing
                    alpha_nt = forcing['icec2'][n-2+t_adj]
                    alpha_adj = np.linspace(alpha_true, alpha_nt, t_adj)
                    forcing['icec2'][n-2:n-2+t_adj] = pwp_out['alpha_true'][n-2:n-2+t_adj]+alpha_adj
                    alpha_n = forcing['icec2'][n-1]
                    transition_ice_frac = False
                    
                    #debug_here()
            
            if params['ice_ON']:
                
                if params['csf'] == True:
                    
                    #computes everything but shortwave
                    q_lw_ao, q_sens_ao, q_lat_ao = get_atm_ocean_HF(temp[0], forcing, alpha_n, n)
                    q_in_ao = (1-alpha_n)*q_in[n-1]
                    q_out_ao = -(q_lw_ao+q_sens_ao+q_lat_ao) #fluxes were defined as positive down. ice fraction already accoutned for
                    q_net_ao = q_in_ao-q_out_ao
                    
                    pwp_out['q_sens_ao'][n-1] = q_sens_ao
                    pwp_out['q_lat_ao'][n-1] = q_lat_ao
                    pwp_out['q_lw_ao'][n-1] = q_lw_ao
                    pwp_out['q_net_ao'][n-1] = q_net_ao
                    
                    q_lw_ai, q_sens_ai, q_lat_ai = get_atm_ice_HF(skt_n, forcing, alpha_n, n)
                    q_in_ai = alpha_n*q_in[n-1]
                    q_out_ai = -(q_lw_ai+q_sens_ai+q_lat_ai) #fluxes were defined as positive down. ice fraction already accoutned for
                    q_net_ai = q_in_ai - q_out_ai
                    F_ai = q_net_ai
                    
                    pwp_out['q_sens_ai'][n-1] = q_sens_ai
                    pwp_out['q_lat_ai'][n-1] = q_lat_ai
                    pwp_out['q_lw_ai'][n-1] = q_lw_ai
                    pwp_out['q_net_ai'][n-1] = q_net_ai
                
                else:
                    q_in_ao = (1-alpha_n)*q_in[n-1]
                    q_out_ao = (1-alpha_n)*q_out[n-1]
                    q_net_ao = q_in_ao - q_out_ao
                    
                    q_in_ai = alpha_n*q_in[n-1]
                    q_out_ai = alpha_n*q_out[n-1]
                    q_net_ai = q_in_ai - q_out_ai
                    F_ai = q_net_ai
                
                print("F_ao: %.2f" %q_net_ao)
                
                #compute ocean->ice heat flux
                F_oi = PWP_ice.get_ocean_ice_heat_flux(temp, sal, dens, params)
                
                #modify existing sea ice
                #h_ice, temp_ice_surf, temp, sal = PWP_ice.modify_existing_ice(temp_ice_surf, h_ice, temp, sal, dens, F_atm, F_ocean, alpha_n, skt_n, params)
                h_ice, temp_ice_surf, temp, sal, F_i = PWP_ice.ice_model_v3(h_ice, skt_n, temp, sal, dens, F_ai, F_oi, alpha_n, params)
                
                
                # apply E-P flux through leads
                sal[0] = sal[0] + sal[0]*(1-alpha_n)*emp[n-1]*dt/dz #TODO: keep track of rain/snow on top of ice (big task)
                
                # apply heat flux through leads
                temp = temp + q_in_ao*absrb*dt/(dz*dens*cpw) #incoming solar
                temp[0] = temp[0] - q_out_ao*dt/(mld_pre*dens[0]*cpw)
                
                #TODO: apply passive scalar flux through leads
                
                
                #check if temp is less than freezing point
                T_fz = sw.fp(sal_old, p=dz) #here it might be better to use sal_old rather than what is essentially brine water
                dT = temp[:mld_idx_pre].mean()-T_fz
                
                if dT<0:
                    temp[:mld_idx_pre] = T_fz
                    
                    print("Creating frazil ice in leads.")
                    
                    #generate sea ice (aka frazil ice)
                    h_ice, temp_ice_surf, temp, sal = PWP_ice.create_initial_ice(h_ice, temp_ice_surf, temp, sal, dens, params)
                    pwp_out['surf_ice_temp'][n] = temp_ice_surf
                    pwp_out['ice_thickness'][n] = h_ice
                    
                    
                    #debug_here()
                
                
                #save ice related output
                pwp_out['surf_ice_temp'][n] = temp_ice_surf
                pwp_out['ice_thickness'][n] = h_ice
                pwp_out['F_oi'][n-1] = F_oi
                pwp_out['F_ai'][n-1] = F_ai
                pwp_out['F_ao'][n-1] = q_net_ao
                pwp_out['F_i'][n-1] = F_i
                pwp_out['alpha_true'][n-1] = alpha_n
            
            else:
                
                print("Whoops! This is unexpected. ")
                print("Need to turn on ice physics.")
                debug_here()
        
        #make sure ocean temp change is consistent with applied
        col_mean_dQ = np.mean(temp-pwp_out['temp'][:, n-1])*dens_ref*cpw*502/dt
        F_net = pwp_out['F_ao'][n-1]-pwp_out['F_oi'][n-1]
        if np.abs(col_mean_dQ-F_net)>0.01:
            print("Warning: Error tolerance exceeded.")
            debug_here()
            
        pwp_out['alpha_true'][n-1] = alpha_n
        
        ### compute new density ###
        dens = sw.dens0(sal, temp)
        
        #save pre-entrainment temp
        temp_pre = temp.copy()
        
        ### relieve static instability ###
        temp, sal, dens, uvel, vvel, ps = remove_si(temp, sal, dens, uvel, vvel, ps)
        
        #compute mlt and mls after entrainment
        mld_post_ent, mld_idx_post_ent = getMLD(dens, z, params)
        dMLD = mld_post_ent - mld_pre
        
        if dMLD<=0:
            F_ent = 0
        else:
            #compute change in heat content of entrained layer
            dT = np.abs(temp[mld_idx_pre:mld_idx_post_ent].mean() - temp_pre[mld_idx_pre:mld_idx_post_ent].mean())
            F_ent = dMLD*dens_ref*cpw*dT/params['dt']
        
        ### Compute MLD ###
        mld, mld_idx = getMLD(dens, z, params)
        
        ### Rotate u,v do wind input, rotate again, apply mixing ###
        ang = -f*dt/2
        uvel, vvel = rot(uvel, vvel, ang)
        du = (taux[n-1]/(mld*dens[0]))*dt
        dv = (tauy[n-1]/(mld*dens[0]))*dt
        uvel[:mld_idx] = uvel[:mld_idx]+du
        vvel[:mld_idx] = vvel[:mld_idx]+dv

        
        ### Apply drag to current ###
        #Original comment: this is a horrible parameterization of inertial-internal wave dispersion
        if ucon > 1e-10:
            uvel = uvel*(1-dt*ucon)
            vvel = vvel*(1-dt*ucon)
        
        uvel, vvel = rot(uvel, vvel, ang)
        
        # debug_here()
        ### Apply Bulk Richardson number instability form of mixing (as in PWP) ###
        if rb > 1e-5:
            temp, sal, dens, uvel, vvel, ps = bulk_mix(temp, sal, dens, uvel, vvel, ps, dz, g, rb, zlen, z, mld_idx)
        
        ### Do the gradient Richardson number instability form of mixing ###
        if rg > 0:
            temp, sal, dens, uvel, vvel, ps = grad_mix(temp, sal, dens, uvel, vvel, ps, dz, g, rg, zlen)
        
        
        ### Apply diffusion ###
        if params['rkz'] > 0:
            temp = diffus(params['dstab'], zlen, temp)
            sal = diffus(params['dstab'], zlen, sal)
            dens = sw.dens0(sal, temp)
            uvel = diffus(params['dstab'], zlen, uvel)
            vvel = diffus(params['dstab'], zlen, vvel)
            ps = diffus(params['dstab'], zlen, ps)
        
        # find MLD again, after all mixing processes complete
        mld_idx = np.flatnonzero(dens-dens[0]>params['mld_thresh'])[0] #finds the first index that exceed ML threshold
        mld_post_mix = z[mld_idx]
        
        # find MLD by interpolating to the exact value
        mld_idx2 = np.flatnonzero(dens-dens[0]==0)[-1] #finds the last index of ML
        from scipy.interpolate import interp1d
        p_int = interp1d(dens[mld_idx2:], z[mld_idx2:]) # interp1d does not work well with perfectly homogenous mixed layers
        mld_exact = p_int(dens[mld_idx2]+params['mld_thresh'])
        mld_exact2 = p_int(dens[mld_idx2]+0.01) #
        
        #save MLT, MLS and MLT_elevation
        MLS_post = np.mean(sal[:mld_idx]);
        MLT_post = np.mean(temp[:mld_idx])
        #T_fz = sw.fp(MLS_post, 0)
        T_elev = MLT_post - T_fz
    
        ### update output profile data ###
        pwp_out['temp'][:, n] = temp
        pwp_out['sal'][:, n] = sal
        pwp_out['dens'][:, n] = dens
        pwp_out['uvel'][:, n] = uvel
        pwp_out['vvel'][:, n] = vvel
        pwp_out['ps'][:, n] = ps
        pwp_out['mld'][n] = mld_post_mix
        pwp_out['mlt'][n] = MLT_post
        pwp_out['mls'][n] = MLS_post
        pwp_out['mlt_elev'][n] = T_elev
        pwp_out['mld_exact'][n] = mld_exact
        pwp_out['mld_exact2'][n] = mld_exact2
        # pwp_out['F_atm'][n] = (1-alpha_n)*F_atm
        pwp_out['F_ent'][n] = F_ent
        pwp_out['alpha_true'][n] = alpha_n
        
        #do diagnostics
        if diagnostics==1:
            phf.livePlots(pwp_out, n)
        
    pwp_out['ice_start'] = np.array(pwp_out['ice_start'])
    
    return pwp_out
    

def remove_si(t, s, d, u, v, ps):
    
    # Find and relieve static instability that may occur in the
    # density array 'd'. This simulates free convection.
    # ml_index is the index of the depth of the surface mixed layer after adjustment,
    
    stat_unstable = True
    
    while stat_unstable:
        
        d_diff = np.diff(d)
        if np.any(d_diff<0):
            stat_unstable=True
            first_inst_idx = np.flatnonzero(d_diff<0)[0]+1 #+1 because of diff function
            #d0 = d
            (t, s, d, u, v, ps) = mix5(t, s, d, u, v, ps, first_inst_idx)
            
            #plot density
            # plt.figure(num=86)
            # plt.clf() #probably redundant
            # plt.plot(d0-1000, range(len(d0)), 'b-', label='pre-mix')
            # plt.plot(d-1000, range(len(d0)), 'r-', label='post-mix')
            # plt.gca().invert_yaxis()
            # plt.xlabel('Density-1000 (kg/m3)')
            # plt.grid(True)
            # plt.pause(0.05)
            # plt.show()
            
            #debug_here()
        else:
            stat_unstable = False
    
    return t, s, d, u, v, ps
    

def mix5(t, s, d, u, v, ps, j):
    
    #This subroutine mixes the arrays t, s, u, v down to level j (level where there is instability).
    j = j+1 #so that the j-th layer is included in the mixing
    t[:j] = np.mean(t[:j])
    s[:j] = np.mean(s[:j])
    d[:j] = sw.dens0(s[:j], t[:j])
    #d[:j] = np.mean(d[:j]) #doing ignores the non-linearities in the eqn of state
    u[:j] = np.mean(u[:j])
    v[:j] = np.mean(v[:j])
    ps[:j] = np.mean(ps[:j])
    
    return t, s, d, u, v, ps

def rot(u, v, ang):
    
    #This subroutine rotates the vector (u,v) through an angle, ang
    r = (u+1j*v)*np.exp(1j*ang)
    u = r.real
    v = r.imag
    
    return u, v

def bulk_mix(t, s, d, u, v, ps, dz, g, rb, nz, z, ml_idx):
    #sub-routine to do bulk richardson mixing
    
    rvc = rb #critical rich number??
    
    for j in range(ml_idx, nz):
        h   = z[j]
        dd  = (d[j]-d[0])/d[0]
        dv  = (u[j]-u[0])**2+(v[j]-v[0])**2
        
        if dv == 0:
            rv = np.inf
        else:
            rv = g*h*dd/dv
        
        if rv > rvc:
            break
        
        else:
            t, s, d, u, v, ps = mix5(t, s, d, u, v, ps, j)
    
    return t, s, d, u, v, ps

def grad_mix(t, s, d, u, v, ps, dz, g, rg, nz):
    
    #copied from source script:
    # %  This function performs the gradeint Richardson Number relaxation
    # %  by mixing adjacent cells just enough to bring them to a new
    # %  Richardson Number.
    # %  Compute the gradeint Richardson Number, taking care to avoid dividing by
    # %  zero in the mixed layer.  The numerical values of the minimum allowable
    # %  density and velocity differences are entirely arbitrary, and should not
    # %  effect the calculations (except that on some occasions they evidently have!)
    #print "entered grad mix"
    
    rc = rg #critical rich. number
    j1 = 0
    j2 = nz-1
    j_range = np.arange(j1, j2)
    i = 0 #loop count
    #debug_here()
    
    while 1:
        #TODO: find a better way to do implement this loop
        
        r = np.zeros(len(j_range),)
        
        for j in j_range:
            dd = (d[j+1]-d[j])/d[j]
            dv = (u[j+1]-u[j])**2+(v[j+1]-v[j])**2
            if dv == 0:
                r[j] = np.inf
            else:
                #compute grad. rich. number
                r[j] = g*dz*dd/dv
        
        #find the smallest value of r in the profile
        r_min = np.min(r)
        j_min_idx = np.argmin(r)
        
        #Check to see whether the smallest r is critical or not.
        if r_min > rc:
            break
        
        #Mix the cells j_min_idx and j_min_idx+1 that had the smallest Richardson Number
        t, s, d, u, v, ps = stir(t, s, d, u, v, ps, rc, r_min, j_min_idx)
        
        #recompute the rich number over the part of the profile that has changed
        j1 = j_min_idx-2
        if j1 < 1:
             j1 = 0
        
        j2 = j_min_idx+2
        if j2 > nz-1:
             j2 = nz-1
        
        i+=1
    
    return t, s, d, u, v, ps

def stir(t, s, d, u, v, ps, rc, r, j):
    
    #copied from source script:
    
    # %  This subroutine mixes cells j and j+1 just enough so that
    # %  the Richardson number after the mixing is brought up to
    # %  the value rnew. In order to have this mixing process
    # %  converge, rnew must exceed the critical value of the
    # %  richardson number where mixing is presumed to start. If
    # %  r critical = rc = 0.25 (the nominal value), and r = 0.20, then
    # %  rnew = 0.3 would be reasonable. If r were smaller, then a
    # %  larger value of rnew - rc is used to hasten convergence.
    #
    # %  This subroutine was modified by JFP in Sep 93 to allow for an
    # %  aribtrary rc and to achieve faster convergence.
    
    #TODO: This needs better commenting
    rcon = 0.02+(rc-r)/2
    rnew = rc+rcon/5.
    f = 1-r/rnew
    
    #mix temp
    dt = (t[j+1]-t[j])*f/2.
    t[j+1] = t[j+1]-dt
    t[j] = t[j]+dt
    
    #mix sal
    ds = (s[j+1]-s[j])*f/2.
    s[j+1] = s[j+1]-ds
    s[j] = s[j]+ds
    
    #mix passive scalar
    d_ps = (ps[j+1]-ps[j])*f/2.
    ps[j+1] = ps[j+1]-d_ps
    ps[j] = ps[j]+d_ps
    
    #recompute density
    #d[j:j+1] = sw.dens0(s[j:j+1], t[j:j+1])
    #have to be careful here. x[j:j+1] in python is not the same as x[[j,j+1]]. We want the latter
    d[[j,j+1]] = sw.dens0(s[[j,j+1]], t[[j,j+1]])
    
    #mix velocities
    du = (u[j+1]-u[j])*f/2
    u[j+1] = u[j+1]-du
    u[j] = u[j]+du
    
    dv = (v[j+1]-v[j])*f/2
    v[j+1] = v[j+1]-dv
    v[j] = v[j]+dv
    
    return t, s, d, u, v, ps

def diffus(dstab,nz,a):
    
    "finite difference implementation of diffusion equation"
    
    #matlab code:
    #a(2:nz-1) = a(2:nz-1) + dstab*(a(1:nz-2) - 2*a(2:nz-1) + a(3:nz));
    
    a[1:nz-1] = a[1:nz-1] + dstab*(a[0:nz-2] - 2*a[1:nz-1] + a[2:nz])
    return a

def getMLD(dens, z, params):
    
    #find ml index
    mld_idx = np.flatnonzero(dens-dens[0]>params['mld_thresh'])[0]
    
    #check to ensure that ML is defined
    assert mld_idx.size is not 0, "Error: Mixed layer depth is undefined."
    
    #get MLD
    mld = z[mld_idx-1]
    
    if mld_idx==1:
        mld = params['dz']
    
    return mld, mld_idx

def get_atm_ocean_HF(sst, forcing, alpha, n):
    
    """
    Function to compute ocean atmosphere heat fluxes in the presence of sea ice.
    
    flux sign convention: postive-down
    
    This is loosely based on Large and Yeager 2004
    Q = f_i*Q_io + f_o*Q_ao
    """
    
    def psi(zeta):
        
        X_o = (1-16*zeta)**(0.25)
        
        if zeta>=0:
            #stable
            psi_m = -5*zeta
            psi_h = -5*zeta
        else:
            #unstable
            psi_m = 2*np.log((1.+X_o)/2.) + np.log((1.+X_o**2)/2.) - 2*np.arctan(X_o) + np.pi/2
            psi_h = 2*np.log((1.+X_o**2)/2.)
        
        return psi_m, psi_h
    
    
    sst_K = sst+273.13
    
    #define params
    f_i = alpha
    f_o = 1-f_i
    q1_ocn = 0.98*640380. #kg/m3 (Large and Yeager 2004 pg. 7)
    q2_ocn = -5107.4 #K
    rho_air = 1.22 #kg/m3
    c_p_air = 1000.5 #J/kg/K (specific heat of air)
    L_v = 2.5e6 #J/kg (Latent heat of evaporation)
    kappa = 0.4 #von karman constant
    g = 9.81 #acc due to gracity
    r = 287 #J/kg/K ideal gas constant
    
    #get key atmospheric forcing variables
    q_2m = forcing['shum2m'][n-1]
    atemp2m = forcing['atemp2m'][n-1]
    u10m = forcing['u10m'][n-1]
    v10m = forcing['v10m'][n-1]
    tx = forcing['tx'][n-1]
    ty = forcing['ty'][n-1]
    
    Un_10m_init = np.sqrt(u10m**2 + v10m**2) #10m wind speed
    q_sat_ocn = (1./rho_air)*q1_ocn*np.e**(q2_ocn/sst_K) #saturation specific humidity
    theta_2m = atemp2m*(1000./1002.)**(r/c_p_air) #potential air temp
    theta_v_2m = theta_2m*(1. + 0.608*q_2m) #virtual potential air temp
    
    #define turbulent heat transfer coefficients (assuming unstable atmosphere)
    C_d = (1e-3)*(2.7/Un_10m_init + 0.142 + Un_10m_init/13.09)
    C_e = (1e-3)*34.6*np.sqrt(C_d)
    C_h = (1e-3)*32.7*np.sqrt(C_d)
    
    # the next series of steps are from Large and Yeager (2004) pg.8-9
    # the goal is to shift the air temp and spec. humidity from 2m to 10m
    
    #define a few more parameters
    # u_star = np.sqrt(np.sqrt(tx**2 + ty**2)/rho_air)
    u_star = np.sqrt(C_d)*Un_10m_init
    # theta_star_2m_ocn = theta_2m - sst_K
    # q_star_2m_ocn = q_2m - q_sat_ocn
    t_star_2m_ocn = (C_h/np.sqrt(C_d))*(theta_2m - sst_K)
    q_star_2m_ocn = (C_e/np.sqrt(C_d))*(q_2m - q_sat_ocn)
    
    
    #compute initial sensible and latent heat fluxes
    q_sens_ao_init = f_o*rho_air*c_p_air*C_h*(theta_2m - sst_K)*Un_10m_init
    q_lat_ao_init = f_o*L_v*rho_air*C_e*(q_2m - q_sat_ocn)*Un_10m_init
    
    #get monin-obukhov length scale
    # L_mo_ocn = -rho_air*c_p_air*theta_v_2m*u_star**3/(kappa*g*qsens_ao_init)
    
    #compute stability parameters
    z_t = 2.
    z_q = 2.
    z_u = 10.
    zeta_2m = (kappa*g*z_t/u_star**2)*(t_star_2m_ocn/theta_v_2m + q_star_2m_ocn/(q_2m + 1./0.608))
    zeta_10m = (kappa*g*z_u/u_star**2)*(t_star_2m_ocn/theta_v_2m + q_star_2m_ocn/(q_2m + 1./0.608))
    
    psi_m_2m, psi_h_2m  = psi(zeta_2m)
    psi_m_10m, psi_h_10m  = psi(zeta_10m)
    
    #shift wind speed to 10m and neutral stability, and temp and hum to the wind height
    Un_10m = Un_10m_init*(1 + (np.sqrt(C_d)/kappa)*(np.log(z_u/z_u) - psi_m_10m))**(-1)
    theta_10m = theta_2m - (t_star_2m_ocn/kappa)*(np.log(z_t/z_u) + psi_h_10m - psi_h_2m) #paper says t_star instead of q_star???
    q_10m = q_2m - (q_star_2m_ocn/kappa)*(np.log(z_t/z_u) + psi_h_10m - psi_h_2m)
    
    #update intial transfer coefficients
    C_d_new = C_d*(1+ (np.sqrt(C_d)/kappa)*(np.log(z_u/z_u) - psi_m_10m) )**(-2.)
    C_h_new = C_h*np.sqrt(C_d_new/C_d)*(1+ (C_h/(kappa*np.sqrt(C_d)) )*(np.log(z_u/z_u) - psi_h_10m))**(-1.)
    C_e_new = C_e*np.sqrt(C_d_new/C_d)*(1+ (C_e/(kappa*np.sqrt(C_d)) )*(np.log(z_u/z_u) - psi_h_10m))**(-1.)
    
    #recompute qsens and qlat
    # theta_star_10m_ocn = theta_10m - sst_K
    # q_star_10m_ocn = q_10m - q_sat_ocn
    
    q_sens_ao = f_o*rho_air*c_p_air*C_h_new*(theta_10m - sst_K)*Un_10m
    q_lat_ao = f_o*L_v*rho_air*C_e_new*(q_10m - q_sat_ocn)*Un_10m
    
    
    #get longwave over the ocean
    sigma = 5.67e-8 #W/m2/K4 (step-boltzmann constant)
    eps = 1.0 #emissivity
    q_lw_ao = f_o*(forcing['dlw'][n-1] - eps*sigma*sst_K**4)
    
    # theta_v_10m = theta_10m*(1. + 0.608*q_10m)
    # t_star_10m_ocn = (C_h/np.sqrt(C_d))*theta_star_10m_ocn
    # q_star_10m_ocn = (C_e/np.sqrt(C_d))*q_star_10m_ocn
    
    print("q_sens_ao = %.2f, q_lat_ao = %.2f, q_lw_ao = %.2f W/m2" %(q_sens_ao, q_lat_ao, q_lw_ao))
    #
    # if n%500==0 and n<=1500:
    #     debug_here()
    
    return q_lw_ao, q_sens_ao, q_lat_ao
    

def get_atm_ice_HF(surf_temp, forcing, alpha, n):
    
    """
    Like get_ocean_atm_HF() but for ice-atmosphere fluxes.
    
    Don't really need this if we are prescribing the surface temp of the sea ice
    
    TODO: combine the two functions
    """
    
    surf_temp_K = surf_temp+273.13
    
    
    #define params
    f_i = alpha
    f_o = 1-f_i
    q1 = 11637800 #kg/m3 (Large and Yeager 2004 pg. 16)
    q2 = -5897.8 #K
    rho_air = 1.22 #kg/m3
    c_p_air = 1000.5 #J/kg/K (specific heat of air)
    L_v = 2.5e6 #J/kg
    L_f = 2.839e6 #J/kg (Latent heat of sublimation)
    kappa = 0.4 #von karman constant
    g = 9.81 #acc due to gracity
    r = 287 #J/kg/K ideal gas constant
    C_e,C_h,C_d = 1.63e-3, 1.63e-3, 1.63e-3
    
    #get key atmospheric forcing variables
    q_2m = forcing['shum2m'][n-1]
    atemp2m = forcing['atemp2m'][n-1]
    u10m = forcing['u10m'][n-1]
    v10m = forcing['v10m'][n-1]
    tx = forcing['tx'][n-1]
    ty = forcing['ty'][n-1]
    
    U_10m = np.sqrt(u10m**2 + v10m**2) #10m wind speed
    q_sat_ice = (1/rho_air)*q1*np.e**(q2/surf_temp_K) #saturation specific humidity
    theta_2m = atemp2m*(1000./1002.)**(r/c_p_air) #potential air temp
    theta_v_2m = theta_2m*(1. + 0.608*q_2m) #virtual potential air temp
    
    #compute latent and sens heat fluxes over ice
    q_lat_ai = f_i*L_f*rho_air*C_e*(q_2m-q_sat_ice)*U_10m
    q_sens_ai = f_i*rho_air*C_h*(theta_2m-surf_temp_K)*U_10m
    
    #compute lw radiation over ice
    sigma = 5.67e-8 #W/m2/K4 (step-boltzmann constant)
    eps = 0.95 #emissivity
    q_lw_ai = f_i*eps*(forcing['dlw'][n-1] - sigma*surf_temp_K**4)
    
    #debug_here()
    
    return q_lw_ai, q_sens_ai, q_lat_ai

if __name__ == "__main__":
    
    print("Running default test case using data from Beaufort gyre...")
    
    forcing_fname = 'beaufort_met.nc'
    prof_fname = 'beaufort_profile.nc'
    run(met_data=forcing_fname, prof_data=prof_fname)
